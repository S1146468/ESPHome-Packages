substitutions:
  device:
    id: climateDevice
    name: "Climate Device"
  climate:
    id: climate
    name: "climate"
    demand: room_demand
    pid_output: pid_output
    interval: 15s
  control:
    pid:
      kp: 0.0
      ki: 0.0
      kd: 0.0
    deadband:
      kp_multiplier: 0.0
      ki_multiplier: 0.0
      kd_multiplier: 0.0
  sensor:
    temperature: sensor.temperature
    humidity: sensor.humidity
    window: binary_sensor.window
  master: climate.name


button:
  - platform: template
    id: ${device.id}_reset_integral
    on_press:
      - climate.pid.reset_integral_term: ${climate.id}
    internal: True

  - platform: template
    id: ${device.id}_PID_autotune_start
    name: "${device.name} PID autotune"
    device_id: ${device.id}
    entity_category: config
    on_press:
      then:
       - script.execute: ${device.id}_run_pid_autotune

script:
  - id: ${device.id}_run_pid_autotune
    then:
      - climate.pid.set_control_parameters:
          id: ${climate.id}
          kp: 0.0
          ki: 0.0
          kd: 0.0
      - climate.pid.autotune:
          id: ${climate.id}
          noiseband: 0.25
          positive_output: 1.0
          negative_output: 0.0
          
  - id: ${device.id}_sync_target_and_hvac
    then:
      - lambda: |-
          using namespace esphome;

          auto climate = id(${climate.id});  // Access the climate object
          float currentSetpoint = climate->target_temperature;
          climate::ClimateMode currentMode = climate->mode;

          climate::ClimateMode climateMode = climate::CLIMATE_MODE_OFF;
          float target = NAN;

          // 1) Map HA hvac_mode -> PID climate mode (only 'heat' or 'off')
          if (id(${device.id}_ha_hvac_mode).state == "heat") climateMode = climate::CLIMATE_MODE_HEAT;

          // 2) Determine target setpoint
          if (id(${device.id}_ha_target_temp).has_state()) target = id(${device.id}_ha_target_temp).state;
          
          if(id(${device.id}_window).state == 1.0)
          {
            climateMode = climate::CLIMATE_MODE_OFF;
            target = 4;
          }

          if(currentSetpoint == target && currentMode == climateMode){
            return;
          }

          // 3) Apply both in a single control call
          auto call = id(${climate.id}).make_call();
          call.set_mode(climateMode);
          if (!isnan(target)) call.set_target_temperature(target);
          call.perform();


globals:
  - id: ${device.id}_previous_setpoint
    type: float
    initial_value: "22.0"

  - id: ${device.id}_heat_output_level
    type: float
    restore_value: no
    initial_value: "0.0"

switch:
  - platform: template
    id: ${device.id}_heat_output_switch
    name: "${device.name} Heat Output Switch"
    device_id: ${device.id}
    entity_category: config
    turn_on_action:
      - switch.template.publish:
          id: ${device.id}_heat_output_switch
          state: ON
    turn_off_action:
      - switch.template.publish:
          id: ${device.id}_heat_output_switch
          state: OFF   

output:
  - platform: template
    id: ${device.id}_heat_output
    type: float
    write_action:
      lambda: |-
        // Window control
        if(isnan(id(${device.id}_window).state))    { id(${device.id}_heat_output_level) = state; return; } // Turn on heating control when window state is unavailable
        if(id(${device.id}_window).state == 1.0)    { id(${device.id}_heat_output_level) = 0.0;   return; } // Turn off heating control when window is open       
        if(id(${device.id}_window).state == 0.0)    { id(${device.id}_heat_output_level) = state; return; } // Turn on heating control when window is closed
  
  - platform: template
    id: ${device.id}_cool_output
    type: float
    write_action: []
        

interval:
  - interval: ${climate.interval}
    then:
      lambda: |-
        auto climate = id(${climate.id});  // Access the climate object
        float current_setpoint = climate->target_temperature;
        if (current_setpoint != id(${device.id}_previous_setpoint)) {
          id(${device.id}_previous_setpoint) = current_setpoint;
          id(${device.id}_reset_integral).press();
        }

  - interval: 1min
    then:
      - script.execute: ${device.id}_sync_target_and_hvac


climate:
  - platform: pid
    id: ${climate.id}
    name: ${climate.name}
    device_id: ${device.id}    
    sensor: ${device.id}_temperature
    humidity_sensor: ${device.id}_humidity
    default_target_temperature: 21°C
    heat_output: ${device.id}_heat_output
    cool_output: ${device.id}_cool_output
    internal: true
    visual:
      min_temperature: 4
      max_temperature: 35
      temperature_step: 
        target_temperature: 0.5
        current_temperature: 0.1
    control_parameters:
      kp: ${control.pid.kp}
      ki: ${control.pid.ki}
      kd: ${control.pid.kd}
      min_integral: -10.0
      max_integral: 10.0
      starting_integral_term: 0.0
      derivative_averaging_samples: 5
    deadband_parameters:
      threshold_low: -0.5
      threshold_high: 0.5
      kp_multiplier: ${control.deadband.kp_multiplier}
      ki_multiplier: ${control.deadband.ki_multiplier}
      kd_multiplier: ${control.deadband.kd_multiplier}
      deadband_output_averaging_samples: 30




binary_sensor:
  - platform: homeassistant 
    name: "Window Sensor"
    entity_id: ${sensor.window}
    id: ${device.id}_window
    
  - platform: template
    name: "${device.name} Window"
    id: ${device.id}_window_kamer_template
    device_id: ${device.id}
    entity_category: diagnostic
    device_class: window
    lambda: |-
      return id(${device.id}_window).state;
    on_release: 
      then:
        - button.press: ${device.id}_reset_integral
        - script.execute: ${device.id}_sync_target_and_hvac


# --- Read HA climate values ---
# HA state string is the current hvac_mode (e.g., "heat", "off", etc.)
text_sensor:
  - platform: homeassistant
    id: ${device.id}_ha_hvac_mode
    entity_id: ${master}
    on_value: 
      then:
        - script.execute: ${device.id}_sync_target_and_hvac

# HA target temperature (single setpoint). If your HA climate uses ranges, add low/high attributes too.
sensor:
  - platform: homeassistant
    id: ${device.id}_ha_target_temp
    entity_id: ${master}
    attribute: temperature
    accuracy_decimals: 1
    on_value: 
      then:
        - script.execute: ${device.id}_sync_target_and_hvac

  - platform: homeassistant 
    name: "${device.name} Temperature Sensor"
    entity_id: ${sensor.temperature}
    id: ${device.id}_temperature
    filters: 
      - heartbeat: ${climate.interval}
      - lambda: |-
          const float filterFactor = 0.1f;
          float keepFactor = 1.0f - filterFactor;
          float value = id(${device.id}_temperature).state;

          if (isnan(value)) return x;

          if (isnan(x)) return keepFactor * value + 0.0;  // Default fallback value
          else return keepFactor * value + x * filterFactor;
          
          

  - platform: homeassistant 
    name: "${device.name} Humidity Sensor"
    entity_id: ${sensor.humidity}
    id: ${device.id}_humidity
    filters: 
      - heartbeat: ${climate.interval}
      - lambda: |-
          const float filterFactor = 0.1f;
          float keepFactor = 1.0f - filterFactor;
          float value = id(${device.id}_humidity).state;

          if (isnan(value)){
            return x;
          }

          if (isnan(x)) {
            return keepFactor * value + 0.0;  // Default fallback value
          } else {
            return keepFactor * value + x * filterFactor;
          }

  - platform: template
    name: "${device.name} Heat output"
    id: ${climate.pid_output}
    device_id: ${device.id}
    unit_of_measurement: "%"
    icon: "mdi:gauge"
    state_class: measurement
    filters: 
      - multiply: !lambda return 100.0;
      - clamp: 
          max_value: 100.0
          min_value: 0.0
          ignore_out_of_range: false
      - round: 0
      - lambda: |-
          // Visual heating state in home assistant
          if(x < 0.0f)  id(${device.id}_heat_output_switch).turn_off();
          if(x == 0.0f) id(${device.id}_heat_output_switch).turn_off();
          if(x > 0.0f)  id(${device.id}_heat_output_switch).turn_on();

          return x;
    update_interval: ${climate.interval}
    lambda: |- 
      return id(${device.id}_heat_output_level);

  - platform: template
    id: ${climate.demand}
    name: "${device.name} Room Demand"
    update_interval: ${climate.interval}
    accuracy_decimals: 2
    unit_of_measurement: ""
    filters:
      - exponential_moving_average:
          alpha: 0.3
          send_every: 1
          send_first_at: 1
    lambda: |-
      // Inputs
      const float T   = id(climate_stijn_temperature).state;     // your room temp sensor
      const float Tsp = id(verwarming_stijn).target_temperature; // your ESPHome PID climate
      float dv = id(${pid_output.room_1}).state / 100.0f;        // [%] → [0..1]

      // Guards
      if (isnan(T) || isnan(Tsp) || isnan(dv)) return 0.0f;

      // Normalized temperature error over 1.5 °C band
      float de = (Tsp - T) / 1.5f;
      if (de < 0.0f) de = 0.0f;
      if (de > 1.0f) de = 1.0f;

      // If already at/above setpoint, ignore valve contribution
      if (T >= Tsp) dv = 0.0f;

      // Ignore tiny valve wiggles (<10%)
      if (dv < 0.10f) dv = 0.0f;

      // Combine: demand reflects either strong need or wide-open valve
      float d = de > dv ? de : dv;

      // Small hysteresis to prevent chatter
      static float last_d = 0.0f;
      const float db = 0.05f;
      if (fabsf(d - last_d) < db) d = last_d;
      last_d = d;

      return d;