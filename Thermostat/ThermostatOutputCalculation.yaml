
substitutions:
  water_temp:
    min_temp: "30" 
    max_temp: "70"
  rate:
    up_step_c:   "1.25"   # 5 °C/min * 15 s / 60
    down_step_c: "2.50"   # 10 °C/min * 15 s / 60
  opentherm_update_interval: 15s
  output_entity_name: T_set
  boiler_enable: boiler_enable
  outside_temp_sensor: sensor.outside_temp
  pid_output:
    room_1: esphome_entity
    room_2: esphome_entity

# --- Outside temperature from HA
sensor:
  - platform: homeassistant
    id: outside_temperature_sensor
    entity_id: ${outside_temp_sensor}
    internal: false

   # Final target exposed for writer
  - platform: template
    id: target_water_temperature
    name: "Target Water Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    icon: mdi:coolant-temperature
    update_interval: ${opentherm_update_interval}
    filters:
      - round: 0
    lambda: |-
      // --- HEATING CURVE ASSUMPTIONS ---
      // When it's VERY cold outside:
      const float t_out_cold    = 0.0; // °C outside
      const float t_supply_max  = 70.0;  // °C CV flow target

      // When it's mild outside:
      const float t_out_warm    = 15.0;  // °C outside
      const float t_supply_min  = 40.0;  // °C CV flow target

      // Hard safety clamp so we never request insane values
      const float t_supply_floor   = 40.0; // don't go below this
      const float t_supply_ceiling = 70.0; // don't go above this

      // --- READ OUTDOOR SENSOR ---
      float outdoor = id(outdoor_temperature).state;

      // Fallback if sensor is not valid
      if (isnan(outdoor)) {
        // safe middle value
        return 50.0;
      }

      // --- LINEAR INTERPOLATION ---
      // slope = (min - max) / (warm - cold)
      float slope = (t_supply_min - t_supply_max) / (t_out_warm - t_out_cold);

      // target = max + slope * (Toutdoor - Tcold)
      float target = t_supply_max + slope * (outdoor - t_out_cold);

      // --- CLAMP RESULT ---
      if (target < t_supply_floor)   target = t_supply_floor;
      if (target > t_supply_ceiling) target = t_supply_ceiling;

      return target;





binary_sensor:
# --- Any valve open?
  - platform: template
    id: any_valve_open
    lambda: |-
      return (id(${pid_output.room_1}).state > 5.0f) || (id(${pid_output.room_2}).state > 5.0f);

# --- CH enable logic
  - platform: template
    id: ch_should_enable
    lambda: |-
      if(id(any_valve_open).state)
      {
        id(${boiler_enable}).turn_on();
        return true;
      } else {
        id(${boiler_enable}).turn_off();
        return false;
      }
      return false;

# --- Writer
interval:
  - interval: ${opentherm_update_interval}
    then:
      - lambda: |-
          float target = id(target_water_temperature).state;
          bool enable  = id(ch_should_enable).state;

          if (!isnan(target)) {
            if (enable) {
              id(${output_entity_name}).set_level(target);
            } else {
              id(${output_entity_name}).set_level(0.0f);
            }
          }
