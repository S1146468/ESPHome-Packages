substitutions:
  device:
    id: climateDevice
    name: "Climate Device"
  climate:
    id: climate
    name: "climate"
    pid_output: pid_output
    boiler_active: ch_active
    interval: 15s
  control:
    pid:
      kp: 0.0
      ki: 0.0
      kd: 0.0
    clamp: 
      i_min: 0.0
      i_max: 0.0
    averaging: 
      derivative: 1
      output: 1
    deadband:
      threshold: 
        low: "0.0°C"
        high: "0.0°C"
      multiplier: 
        kp: 0.0
        ki: 0.0
        kd: 0.0
      averaging: 
        output: 1
    autotune:
      noiseband: 50%
      positive_output: 100%
      negative_output: 0%
  sensor:
    temperature: sensor.temperature
    humidity: sensor.humidity
    window: binary_sensor.window
  master: climate.name

    

button:
  - platform: template
    id: ${device.id}_reset_integral
    on_press:
      - climate.pid.reset_integral_term: ${climate.id}
    internal: True

  - platform: template
    id: ${device.id}_PID_autotune_start
    name: "PID autotune"
    device_id: ${device.id}
    entity_category: config
    on_press:
      then:
       - script.execute: ${device.id}_run_pid_autotune

script:
  - id: ${device.id}_run_pid_autotune
    then:
      - lambda: |-
          id(${device.id}_autotune_in_progress) = true;
          // auto call = id(${climate.id}).make_call();
          // call.set_mode("AUTO");
          // // etc. see API reference
          // call.perform();

      - climate.pid.set_control_parameters:
          id: ${climate.id}
          kp: 0.0
          ki: 0.0
          kd: 0.0

      - climate.pid.reset_integral_term: ${climate.id}

      - climate.pid.autotune:
          id: ${climate.id}
          noiseband: ${control.autotune.noiseband}
          positive_output: ${control.autotune.positive_output}
          negative_output: ${control.autotune.negative_output}
          
  - id: ${device.id}_sync_target_and_hvac
    then:
      - lambda: |-
          using namespace esphome;

          if(id(${device.id}_autotune_in_progress)) return;
          
          
          auto climate = id(${climate.id});  // Access the climate object
          float currentSetpoint = climate->target_temperature;
          climate::ClimateMode currentMode = climate->mode;

          climate::ClimateMode climateMode = climate::CLIMATE_MODE_OFF;
          float target = NAN;

          // 1) Map HA hvac_mode -> PID climate mode (only 'heat' or 'off')
          if (id(${device.id}_ha_hvac_mode).state == "heat") climateMode = climate::CLIMATE_MODE_HEAT;

          // 2) Determine target setpoint
          if (id(${device.id}_ha_target_temp).has_state()) target = id(${device.id}_ha_target_temp).state;
          
          if(id(${device.id}_window).state == 1.0)
          {
            climateMode = climate::CLIMATE_MODE_OFF;
            target = 4;
          }

          if(currentSetpoint == target && currentMode == climateMode){
            return;
          }

          // 3) Apply both in a single control call
          auto call = id(${climate.id}).make_call();
          call.set_mode(climateMode);
          if (!isnan(target)) call.set_target_temperature(target);
          call.perform();


globals:
  - id: ${device.id}_previous_setpoint
    type: float
    initial_value: "5.0"

  - id: ${device.id}_heat_output_level
    type: float
    restore_value: no
    initial_value: "0.0"

  - id: ${device.id}_autotune_in_progress
    type: bool
    restore_value: no
    initial_value: "false"

switch:
  - platform: template
    id: ${device.id}_heat_output_switch
    name: "Heat Output Switch"
    device_id: ${device.id}
    entity_category: config
    turn_on_action:
      - switch.template.publish:
          id: ${device.id}_heat_output_switch
          state: ON
    turn_off_action:
      - switch.template.publish:
          id: ${device.id}_heat_output_switch
          state: OFF   

output:
  - platform: template
    id: ${device.id}_heat_output
    type: float
    write_action:
      lambda: |-
        // Window control
        if(isnan(id(${device.id}_window).state))    { id(${device.id}_heat_output_level) = state; return; } // Turn on heating control when window state is unavailable
        if(id(${device.id}_window).state == 1.0)    { id(${device.id}_heat_output_level) = 0.0;   return; } // Turn off heating control when window is open       
        if(id(${device.id}_window).state == 0.0)    { id(${device.id}_heat_output_level) = state; return; } // Turn on heating control when window is closed


interval:
  - interval: ${climate.interval}
    then:
      lambda: |-
        auto climate = id(${climate.id});  // Access the climate object
        float current_setpoint = climate->target_temperature;
        if (current_setpoint != id(${device.id}_previous_setpoint)) {
          id(${device.id}_previous_setpoint) = current_setpoint;
          id(${device.id}_reset_integral).press();
        }
  
  - interval: ${climate.interval}
    then:
      lambda: |-
        // Visual heating state in home assistant
        bool pid_output = false;
        bool boiler_on = false;

        if(id(${climate.pid_output}).state > 0.0f) pid_output = true;
        if(id(${climate.boiler_active}).state == true) boiler_on = true;
        
        if( pid_output == true && boiler_on == true)
        {
          id(${device.id}_heat_output_switch).turn_on();
        } 
        else 
        {
          id(${device.id}_heat_output_switch).turn_off();
        }

  - interval: 1min
    then:
      - script.execute: ${device.id}_sync_target_and_hvac


climate:
  - platform: pid
    id: ${climate.id}
    name: ${climate.name}
    device_id: ${device.id}    
    sensor: ${device.id}_temperature
    humidity_sensor: ${device.id}_humidity
    default_target_temperature: 5°C
    heat_output: ${device.id}_heat_output
    # cool_output: ${device.id}_cool_output
    internal: true
    visual:
      min_temperature: 4
      max_temperature: 35
      temperature_step: 
        target_temperature: 0.5
        current_temperature: 0.1
    control_parameters:
      kp: ${control.pid.kp}
      ki: ${control.pid.ki}
      kd: ${control.pid.kd}
      min_integral: ${control.clamp.i_min}
      max_integral: ${control.clamp.i_max}
      starting_integral_term: 0.0
      derivative_averaging_samples: ${control.averaging.derivative}
      output_averaging_samples: ${control.averaging.output}
    deadband_parameters:
      threshold_low: ${control.deadband.threshold.low}
      threshold_high: ${control.deadband.threshold.high}
      kp_multiplier: ${control.deadband.multiplier.kp}
      ki_multiplier: ${control.deadband.multiplier.ki}
      kd_multiplier: ${control.deadband.multiplier.kd}
      deadband_output_averaging_samples: ${control.deadband.averaging.output}




binary_sensor:
  - platform: homeassistant 
    entity_id: ${sensor.window}
    id: ${device.id}_window
    on_release: 
      then:
        - button.press: ${device.id}_reset_integral
        - script.execute: ${device.id}_sync_target_and_hvac
    
  - platform: template
    name: "Window"
    id: ${device.id}_window_kamer_template
    device_id: ${device.id}
    device_class: window
    lambda: |-
      return id(${device.id}_window).state;
    


# --- Read HA climate values ---
# HA state string is the current hvac_mode (e.g., "heat", "off", etc.)
text_sensor:
  - platform: homeassistant
    id: ${device.id}_ha_hvac_mode
    entity_id: ${master}
    on_value: 
      then:
        - script.execute: ${device.id}_sync_target_and_hvac

# HA target temperature (single setpoint). If your HA climate uses ranges, add low/high attributes too.
sensor:
  - platform: homeassistant
    id: ${device.id}_ha_target_temp
    entity_id: ${master}
    attribute: temperature
    accuracy_decimals: 1
    on_value: 
      then:
        - script.execute: ${device.id}_sync_target_and_hvac

  - platform: homeassistant 
    entity_id: ${sensor.temperature}
    id: ${device.id}_temperature
    filters: 
      - heartbeat: ${climate.interval}

  - platform: homeassistant 
    entity_id: ${sensor.humidity}
    id: ${device.id}_humidity
    filters: 
      - heartbeat: ${climate.interval}


   



  - platform: template
    name: "Heat output"
    id: ${climate.pid_output}
    device_id: ${device.id}
    unit_of_measurement: "%"
    state_class: measurement
    icon: "mdi:heat-wave"
    filters: 
      - multiply: !lambda return 100.0;
      - clamp: 
          max_value: 100.0
          min_value: 0.0
          ignore_out_of_range: false
      - round: 0
    update_interval: ${climate.interval}
    lambda: |- 
      float x = id(${device.id}_heat_output_level);

      // if (x < 0.05f)  {
      //   x = 0.0f;
      // } else {
      //   x = x * 0.75f + 0.25f;
      // }
      
      return x;
# #

#   - platform: template
#     name: "Valve Opening Degree"
#     id: ${device.id}_valve_opening_degree
#     device_id: ${device.id}
#     unit_of_measurement: "%"
#     state_class: measurement
#     icon: "mdi:heat-wave"
#     filters: 
#       - clamp: 
#           max_value: 100.0
#           min_value: 0.0
#           ignore_out_of_range: false
#       - round: 0
#     update_interval: ${climate.interval}
#     lambda: |- 
#       float x = id(${device.id}_heat_output_level);
#       return x;

#   - platform: template
#     name: "Valve Closing Degree"
#     id: ${device.id}_valve_closing_degree
#     device_id: ${device.id}
#     unit_of_measurement: "%"
#     state_class: measurement
#     icon: "mdi:heat-wave"
#     filters: 
#       - clamp: 
#           max_value: 100.0
#           min_value: 0.0
#           ignore_out_of_range: false
#       - round: 0
#     update_interval: ${climate.interval}
#     lambda: |- 
#       float x = id(${device.id}_heat_output_level);
#       return x;
# # b