
substitutions:
  water_temp:
    min_temp: "30" 
    max_temp: "70"
  rate:
    up_step_c:   "1.25"   # 5 °C/min * 15 s / 60
    down_step_c: "2.50"   # 10 °C/min * 15 s / 60
  opentherm_update_interval: 15s
  opentherm_update_interval_seconds: 15  # not parsed, adjust if needed
  output_entity_name: T_set
  outside_temp_sensor: sensor.outside_temp
  heat_demand:
    room_1: esphome_entity
    room_2: esphome_entity
  pid_output:
    room_1: room_a_pid_output
    room_2: room_b_pid_output

# --- Outside temperature from HA
sensor:
  - platform: homeassistant
    id: outside_temperature_sensor
    entity_id: ${outside_temp_sensor}
    internal: false


  # Max room demand (0..1)
  - platform: template
    id: max_room_demand
    name: "Max Room Demand"
    accuracy_decimals: 2
    update_interval: ${opentherm_update_interval}
    lambda: |-
      float a = id(${heat_demand.room_1}).state;
      float b = id(${heat_demand.room_2}).state;
      if (isnan(a)) a = 0.0f;
      if (isnan(b)) b = 0.0f;
      return a > b ? a : b;

  # Raw flow target with outdoor bias and clamps
  - platform: template
    id: flow_target_raw
    name: "Flow Target Raw"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: ${opentherm_update_interval}
    lambda: |-
      const float Tmin = ${water_temp.min_temp};
      const float Tmax = ${water_temp.max_temp};
      const float k    = 1.0f;   // °C flow per °C below Tref
      const float Tref = 10.0f;  // reference outdoor °C

      float D = id(max_room_demand).state;
      if (isnan(D)) D = 0.0f;

      float Tout = id(outside_temperature_sensor).state;
      if (isnan(Tout)) Tout = Tref;

      float Tdem = Tmin + D * (Tmax - Tmin);
      float B    = k * (Tref - Tout);
      float Tf   = Tdem + B;

      if (Tf < Tmin) Tf = Tmin;
      if (Tf > Tmax) Tf = Tmax;
      return Tf;

  # Rate-limited flow target (protect boiler)
  - platform: template
    id: flow_target_rl
    name: "Flow Target (Rate-Limited)"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: ${opentherm_update_interval}
    lambda: |-
      static float last = ${water_temp.min_temp};
      float target = id(flow_target_raw).state;

      const float up_step   = ${rate.up_step_c};
      const float down_step = ${rate.down_step_c};

      if (target > last + up_step)   target = last + up_step;
      if (target < last - down_step) target = last - down_step;

      last = target;
      return target;

  # Final target exposed for writer
  - platform: template
    id: target_water_temperature
    name: "Target Water Temperature"
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: ${opentherm_update_interval}
    lambda: |-
      return id(flow_target_rl).state;

binary_sensor:
# --- Any valve open?
  - platform: template
    id: any_valve_open
    lambda: |-
      return (id(${pid_output.room_1}).state > 5.0f) ||
             (id(${pid_output.room_2}).state > 5.0f);

# --- CH enable logic
  - platform: template
    id: ch_should_enable
    lambda: |-
      return id(max_room_demand).state >= 0.10f && id(any_valve_open).state;

# --- Writer
interval:
  - interval: ${opentherm_update_interval}
    then:
      - lambda: |-
          float target = id(target_water_temperature).state;
          bool enable  = id(ch_should_enable).state;

          if (!isnan(target)) {
            if (enable) {
              id(${output_entity_name}).set_level(target);
            } else {
              id(${output_entity_name}).set_level(20.0f);
            }
          }
